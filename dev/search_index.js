var documenterSearchIndex = {"docs":
[{"location":"IASI/#IASI","page":"IASI","title":"IASI","text":"The Infrared Atmospheric Sounding Interferometer (IASI) is an instrument on the METOP satellites. It is a hyper-spectral infrared sensor measuring upwelling radiation from a sun-synchronous orbit in 8461 spectral channels (645.0 - 2760.0 cm-1). These measurements are used to derive a plethora of geophysical variables (e.g. temperature and humidity profiles). This makes IASI a key data source for numerical weather prediction (NWP) and applications in atmospheric chemistry and monitoring of essential climate variables. See IASI Level 1 product page and IASI Level 2 product page for more information.","category":"section"},{"location":"IASI/#Static-plot-of-L1C-spectra","page":"IASI","title":"Static plot of L1C spectra","text":"This example is made using the following packages.\n\n[13f3f980] CairoMakie v0.12.16\n[db073c08] GeoMakie v0.7.9\n\nThe key variable is \"gs1cspect\" which contains the radiance spectra measured by IASI. The spectra from a full orbit are almost 2 GB of data. In this example we will just load one data record with observation locations and plot the spectra of two observations. The spectra are converted from radiances to brightness temperature since this is often convenient when interpreting the IASI spectra. The cloud cover in each individual field of view (from AVHRR) is also read from the file and included as legends on the plot of the spectra.  \n\nusing MetopDatasets\nusing CairoMakie, GeoMakie\n\nds = MetopDataset(\"IASI_xxx_1C_M01_20240925202059Z_20240925220258Z_N_O_20240925211316Z.nat\", maskingvalue=NaN);\n\n# Select a single data record\ndata_record_index = 670\n\n# Select 2 points to plot the full spectrum \nselected_points = CartesianIndex.([(2,15), (1,27)])\nselected_colors = [:red, :black]\n\n# Read the geolocation of the data record\nlongitude, latitude = let \n    lon_lat = ds[\"ggeosondloc\"][:,:,:,data_record_index]\n    lon_lat[1,:,:], lon_lat[2,:,:]\nend\n\n# read spectrum as brightness temperature\nwavenumber = ds[\"spectra_wavenumber\"][:, data_record_index]\nselected_T_b = let \n    spectra = ds[\"gs1cspect\"][:,:,:,data_record_index]\n    # convert select spectra to brightness temperature\n    [brightness_temperature.(spectra[:,i] , wavenumber) \n        for i in selected_points]\nend\n\n# Read cloud cover for the selected points\nselected_cloud_cover = ds[\"geumavhrr1bcldfrac\"][:,:,data_record_index][selected_points]\n\n# plot the data\nfig = let\n\n    fig = Figure()\n\n    # axis to plot geolocation\n    ax = GeoAxis(fig[1, 1],\n        title = \"Observations\",\n        xlabel = \"longitude\",\n        ylabel = \"latitude\",\n        limits = (extrema(longitude), extrema(latitude)))\n\n    # plot all observations from data record in gray\n    scatter!(ax, longitude[:], latitude[:], color=:gray)\n    # plot selected observations in color\n    scatter!(ax, longitude[selected_points], latitude[selected_points], \n        color=selected_colors, marker=:xcross, markersize = 15)\n\n    # Add coastlines\n    lines!(ax, GeoMakie.coastlines()) \n\n    # Plot the selected spectra\n    ax2 = Axis(fig[2, 1],\n        title = \"Selected spectra\",\n        xlabel = \"Wavenumber (cm-1)\",\n        ylabel = \"Brightness Temperature (K)\",\n        limits=((500,3500), (150,300)))\n\n    for i in eachindex(selected_points)\n        cloud_cover_i = Int(selected_cloud_cover[i])\n        lines!(ax2, wavenumber./100, selected_T_b[i], color = selected_colors[i],\n            label = \"$(cloud_cover_i)% cloud cover\")\n    end\n\n    # Add legends\n    axislegend(ax2, position = :rb)\n\n    fig\nend\n\n(Image: Static IASI spectrum) The top plot shows a row of observations west of the French coast. Two observation have been marked with a colored X. The spectrum of these observations are shown below.","category":"section"},{"location":"IASI/#Advanced-interactive-plots-of-L1C-spectra","page":"IASI","title":"Advanced interactive plots of L1C spectra","text":"This example shows how the IASI spectra can be shown interactively on a responsive map. The example relies on Tyler.jl and GLMakie.jl. It is recommend to first try some examples from the Tyler documentation if you are new to this package. \n\n[e9467ef8] GLMakie v0.10.16\n[e170d443] Tyler v0.2.0\n\nThis example will use Tyler to create an interactive background map similar to google maps in the top panel of the figure. Then all the locations of the observation will be plotted on the map colored based on the cloud cover. The bottom panel will display the spectrum of a single observation. Clicking an observation in the top panel will load that spectrum and plot it in the bottom panel. The loading of the spectrum will be done lazily to conserve memory.\n\nusing Tyler, GLMakie, MetopDatasets\n\nds = MetopDataset(\"IASI_xxx_1C_M01_20240925202059Z_20240925220258Z_N_O_20240925211316Z.nat\", maskingvalue=NaN);\n\n# read geolocation points and data shape\npts, pts_original_size = let\n    lon_lat = ds[\"ggeosondloc\"][:,:,:,:]\n\n    # make sure longitude is from -180 to 180\n    lon_lat[1, :,:,:][ lon_lat[1,:,:,:] .>180] .-= 360\n\n    # convert the points to tuples\n    lon_lat = tuple.(lon_lat[1, :,:,:],lon_lat[2, :,:,:])\n\n    # store the original shape of the points\n    pts_original_size = size(lon_lat)\n\n    # Flatten the points and convert them to web_mercator (the coordinate system used by Tyler)\n    MT = Tyler.MapTiles\n    pts = [Point2f(MT.project(lon_lat[i], MT.wgs84, MT.web_mercator)) \n            for i in eachindex(lon_lat)]\n    \n    pts, pts_original_size\nend;\n\n# read cloud fraction\ncloud_fraction = Float32.(ds[\"geumavhrr1bcldfrac\"][:]);\n\n# helper function to read the spectrum for a single point\nfunction read_spectrum_pts(ds, index::CartesianIndex)\n    # read spectrum and wavenumber\n    spectrum = ds[\"gs1cspect\"][:,Tuple(index)...]\n    wavenumber = ds[\"spectra_wavenumber\"][:, Tuple(index)[end]]\n\n    # covert to brightness temperature\n    T_B = brightness_temperature.(spectrum, wavenumber)\n    wavenumber_cm = wavenumber./100\n\n    # join brightness temperature and wavenumber to points\n    spectrum_pts = Point2f.(tuple.(wavenumber_cm, T_B))\n    return spectrum_pts\nend\n\n# read an initial spectrum\nspectrum_pts = read_spectrum_pts(ds, CartesianIndex(1,1,1));\n\n# create the inter active plot.\nfig = let\n    fig = Figure()\n    \n    # select background map and initial zoom\n    provider = Tyler.TileProviders.Esri(:WorldImagery);\n    extent = Tyler.Extent(X = (-10, 10), Y = (-10, 10));\n\n    # create background map\n    ax1 = Axis(fig[1,1])\n    m = Tyler.Map(extent; provider, figure=fig, axis=ax1);\n    wait(m);\n\n    # Plot observation points with cloud cover\n    objscatter = scatter!(ax1, pts, color = cloud_fraction, \n        colorrange = (0,100), colormap=:grays, markersize=15)\n    # hack from https://github.com/MakieOrg/Tyler.jl/issues/109\n    translate!(objscatter, 0, 0, 10) \n\n    # Plot a red cross on top of the selected point\n    selected_point = Observable(pts[1:1])\n    selected_scatter = scatter!(ax1, selected_point, \n        color = :red, markersize=10, marker =:xcross)\n    # hack from https://github.com/MakieOrg/Tyler.jl/issues/109\n    translate!(selected_scatter, 0, 0, 11)\n\n    # Add colorbar\n    Colorbar(fig[1, 2], limits = (0.0,100.0), colormap =:grays, label = \"Cloud Fraction\")\n    hidedecorations!(ax1)\n\n    # Create the second plot for the spectrum\n    ax2 = Axis(fig[2, 1],\n        title = \"Observation spectrum\",\n        xlabel = \"Wavenumber (cm-1)\",\n        ylabel = \"Brightness Temperature (K)\")\n\n    # plot the spectrum\n    spectrum_observable = Observable(spectrum_pts)\n    lines!(ax2, spectrum_observable)\n    \n    # Add event handler to update the plot when the user click on a new observation \n    obs_func = on(events(m.axis).mousebutton) do event\n        if event.button == Mouse.left && event.action == Mouse.press\n            plt, i = pick(m.axis)\n            if plt == objscatter # check if an observation was clicked\n                # get the CartesianIndex\n                cartesian_i = CartesianIndices(pts_original_size)[i]\n                # load the selected spectrum and update the spectrum plot\n                spectrum_observable[] = read_spectrum_pts(ds, cartesian_i)\n                # update the red x\n                selected_point[] = pts[i:i]\n            end\n        end\n    end\n\n    fig\nend\n\n(Image: Interactive IASI spectrum) It is now possible to interactively explore the nearly 100 000 observations from an obit of IASI with the background map giving important context. ","category":"section"},{"location":"IASI/#Level-2-Combined-Sounding-Products","page":"IASI","title":"Level 2 Combined Sounding Products","text":"The IASI level 2 products contains derived atmospheric profiles of temperature, water vapour, ozone and trace gases. The availability of these profiles depend on cloud cover and therefore the number of profiles will vary through out the product. These variables of changing size are padded with fill values (default to missing) to generate an array that fits with the MetopDataset interface. This example plots the temperature and water vapour profiles next to a map showing the location of the observation. The example uses maskingvalue = NaN for selected variables to avoid missing values. We read the \"first guess\" variables (fg_atmospheric_water_vapour, fg_atmospheric_temperature), because they contain the data from the statistical all-sky retrieval. The 1DVar algorithm that generates the \"non-first guess\" profiles will be phased out in favor of the statistical retrieval in the future.\n\nusing MetopDatasets\nusing CairoMakie, GeoMakie\n\nds = MetopDataset(\"IASI_SND_02_M03_20250120105357Z_20250120123253Z_N_O_20250120123416Z.nat\");\n\n# Select color to plot temperature and humidity profile\nselected_color = :red\n\n# Select a single data record\ndata_record_index = 105\n\n# Read temperature and humidity profiles;\n# we read the profiles from the statistical retrieval with associated quality indicators\ntemperature, humidity, selected_point  = let\n    temp_var = cfvariable(ds, \"fg_atmospheric_temperature\", maskingvalue = NaN)\n    qi_temp_var = cfvariable(ds, \"fg_qi_atmospheric_temperature\", maskingvalue = NaN)\n    humidity_var = cfvariable(ds, \"fg_atmospheric_water_vapour\", maskingvalue = NaN)\n    qi_humidity_var = cfvariable(ds, \"fg_qi_atmospheric_water_vapour\", maskingvalue = NaN)\n    # keep only soundings where the quality indicators are low\n    # thresholds can be relaxed to increase data yield\n    # only look at selected data_record_index to save time\n    good_retrievals = findall(qi_temp_var[:,data_record_index] .< 2 \n                               .&& qi_humidity_var[:,data_record_index] .< 4)\n    # we select the 60th retrieval for plotting\n    selected_point = good_retrievals[60]\n    \n    temp_var[:, selected_point, data_record_index], \n    humidity_var[:, selected_point, data_record_index], selected_point\nend\n\n# Read the geolocation of the data record\nlongitude, latitude = let \n    lat_lon_var = cfvariable(ds, \"earth_location\", maskingvalue = NaN)\n    lat_lon = lat_lon_var[:,:,data_record_index]\n    lat_lon[2,:], lat_lon[1,:]\nend\n\n# Read the pressure levels \ntemp_pressure_levels = cfvariable(ds, \"pressure_levels_temp\", maskingvalue = NaN)[:]\nhum_pressure_levels  = cfvariable(ds, \"pressure_levels_humidity\", maskingvalue = NaN)[:]\n\n# Plot figure\nfig = let\n\n    fig = Figure()\n\n    # axis to plot geolocation\n    ax = GeoAxis(fig[1, 1:2],\n        title = \"Observations\",\n        xlabel = \"longitude\",\n        ylabel = \"latitude\",\n        limits = (extrema(longitude), extrema(latitude)))\n\n    # plot all observations from data record in gray\n    scatter!(ax, longitude[:], latitude[:], color=:gray)\n    # plot selected observations in color\n    scatter!(ax, longitude[[selected_point]], latitude[[selected_point]], \n        color=[selected_color], marker=:xcross, markersize = 15)\n\n    # Add coastlines\n    lines!(ax, GeoMakie.coastlines()) \n\n    # Plot the temperature profile \n    y_limits = (0.001,1900.0)\n\n    ax2 = Axis(fig[2, 1],\n        title = \"Temperature profile\",\n        ylabel = \"Pressure (hPa)\",\n        xlabel = \"(K)\", yreversed = true,\n        limits = (nothing, y_limits),\n\tyscale= log10)\n\n    lines!(ax2,  temperature, temp_pressure_levels/100, color = selected_color)\n    \n    # Plot the temperature profile \n    ax3 = Axis(fig[2, 2],\n        title = \"Water vapour  profile\",\n        ylabel = \"Pressure (hPa)\",\n        xlabel = \"(kg/kg)\", yreversed = true,\n        limits = (nothing, y_limits),\n\tyscale = log10)\n\n    lines!(ax3,  humidity, hum_pressure_levels/100, color = selected_color)\n    hideydecorations!(ax3, grid=false)\n\n    fig\nend\n\n(Image: IASI L2 profile) The top plot shows a row of observations west of the west African coast. One observation has been marked with a colored X. The corresponding temperature and water vapour profile of the observation are shown below.","category":"section"},{"location":"IASI/#Level-2-Carbon-monoxide","page":"IASI","title":"Level 2 Carbon monoxide","text":"This example shows how to plot retrieved carbon monoxide for the IASI L2 products. \n\nusing MetopDatasets\nusing CairoMakie, GeoMakie, Statistics\n\niasi_file = \"IASI_SND_02_M03_20250120105357Z_20250120123253Z_N_O_20250120123416Z.nat\"\nds = MetopDataset(iasi_file , maskingvalue=NaN);\n\n# select the layer for the carbon monoxide\nlayer_index = 15\nheight_in_km = Int.(ds[\"forli_layer_heights_co\"][layer_index])/1000\n\n# get locations\nlongitude, latitude = let \n    lat_lon = ds[\"earth_location\"][:,:,:]\n    lat_lon[2,:,:], lat_lon[1,:,:]\nend\n\n# read carbon monoxide data\nco_integrated = ds[\"integrated_co\"][:,:].*1000 # convert to g/m2\nco_at_height = ds[\"co_cp_co_a\"][layer_index,:,:] .* ds[\"co_x_co\"][layer_index,:,:]\n\n# get color range for plotting\nget_quantiles(a) = quantile(a,0.02), quantile(a,0.98)\nco_range = get_quantiles(co_at_height[.!isnan.(co_at_height)])\nco_integrated_range = get_quantiles(co_integrated[.!isnan.(co_integrated)])\n\n# plot the data\nfig = let\n\n    # Create figure and axis\n    fig = Figure()\n    ax1 = GeoAxis(fig[1, 1],\n        title = \"Carbon monoxide at $height_in_km km\",\n        xlabel = \"longitude\",\n        ylabel = \"latitude\")\n    ax2 = GeoAxis(fig[2, 1],\n        title = \"Carbon monoxide integrated\",\n        xlabel = \"longitude\",\n        ylabel = \"latitude\")\n\n    # Add coastlines\n    lines!(ax1, GeoMakie.coastlines(), color=:black)\n    lines!(ax2, GeoMakie.coastlines(), color=:black) \n\n    # plot observations\n    scatter!(ax1, longitude[:], latitude[:],\n        color = co_at_height[:], colorrange = co_range, markersize = 2)\n    scatter!(ax2, longitude[:], latitude[:],\n        color = co_integrated[:], colorrange = co_integrated_range, markersize = 2)\n\n    # Add colorbar\n    c1 = Colorbar(fig[1,2],colorrange = co_range .*10^-16, label=\"molecules/cm2 x 10^16\")\n    c2 = Colorbar(fig[2,2],colorrange = co_integrated_range, label=\"g/m2\")\n\n    # hide ticks\n    hidedecorations!(ax1, grid = false)\n    hidedecorations!(ax2, grid = false)\n\n    fig\nend\n\n(Image: IASI Carbon monoxide)","category":"section"},{"location":"ATOVS/#ATOVS","page":"ATOVS (AMSU-A, HIRS, MHS)","title":"ATOVS","text":"Advanced TIROS Operational Sounder (ATOVS) is a sounding instrument package. The ATOVS instruments have both been flown on NOAA satellites and on the METOP satellites. The METOP ATOVS instrument package consists of 3 sensors:\n\nAdvanced Microwave Sounding Units A (AMSU-A)\nHigh Resolution InfraRed Sounder (HIRS)\nMicrowave Humidity Sounder (MHS)\n\nFor more information see ATOVS Level 1b Product Guide","category":"section"},{"location":"ATOVS/#AMSU-A","page":"ATOVS (AMSU-A, HIRS, MHS)","title":"AMSU-A","text":"The Advanced Microwave Sounding Unit-A (AMSU-A) is an instrument on the METOP satellites. AMSU-A is a microwave radiometer with 15 channels and is one of the three ATOVS sensors.\n\nThe AMSU-A L1B products contain the radiance measured at all 15 channels. See the AMSU-A Level 1B product pagel for more information. The frequency of each channel is given in NOAA KLM User's Guide\n\nThis example is made using the following packages.\n\n[13f3f980] CairoMakie v0.15.6\n[db073c08] GeoMakie v0.7.15\n\nusing MetopDatasets\nusing CairoMakie, GeoMakie, Statistics\n\n# Open the dataset.\npath = \"AMSA_xxx_1B_M03_20250915221320Z_20250915235520Z_N_O_20250915235036Z.nat\"\nds = MetopDataset(path, maskingvalue=NaN);\n\n# read location\nlatitude = ds[\"earth_location\"][1,:,:]\nlongitude = ds[\"earth_location\"][2,:,:]\n\n# read radiance\nradiance_of_band = ds[\"scene_radiance\"][2,:,:] # Channel 2 is 31.4 GHz\n\nradiance_q05 = quantile(radiance_of_band[:],0.05)\nradiance_q90 = quantile(radiance_of_band[:],0.90)\n\nfig = let\n    # Create figure and axis\n    fig = Figure()\n    ax = GeoAxis(fig[1, 1],\n        title = \"AMSU\",\n        xlabel = \"longitude\",\n        ylabel = \"latitude\")\n\n    # plot data with color map\n        scatter!(ax, longitude[:], latitude[:],\n        color = radiance_of_band[:], colorrange = (radiance_q05,radiance_q90), markersize = 2)\n\n    # Add colorbar\n    Colorbar(fig[1,2], colorrange = (radiance_q05,radiance_q90) , label=\"mW/m2/sr/cm-1\")\n\n    # Add coastlines\n    lines!(ax, GeoMakie.coastlines()) \n    fig\nend\n\n(Image: AMSU-A channel 2) The plot shows the radiance for the AMSU-A channel 2 (31.4 GHz) observed during an orbit.","category":"section"},{"location":"ATOVS/#HIRS","page":"ATOVS (AMSU-A, HIRS, MHS)","title":"HIRS","text":"The High Resolution Infrared Sounder (HIRS) is an instrument on the METOP satellites. It is a 20 channel infrared sounder and one of the three Advanced TIROS Operational Sounder (ATOVS) sensors. \n\nThe level 1B HIRS files contain the radiance of the 19 channels and the reflectance for channel 20.  See the HIRS Level 1B product page for more information.   This example shows how we plot the radiance from channel 7 on a map.\n\nThis example is made using the following packages.\n\n[13f3f980] CairoMakie v0.15.6\n[db073c08] GeoMakie v0.7.15\n\nusing MetopDatasets\nusing CairoMakie, GeoMakie, Statistics\n\n# Open the dataset.\npath = \"HIRS_xxx_1B_M01_20160720074253Z_20160720092153Z_N_O_20160720083048Z.nat\"\nds = MetopDataset(path, maskingvalue=NaN);\n\n# read location\nlatitude = ds[\"earth_location\"][1,:,:]\nlongitude = ds[\"earth_location\"][2,:,:]\n\n# read radiance\nradiance_of_band = ds[\"digital_a_rad\"][7,:,:] # Channel 7\n\nradiance_q05 = quantile(radiance_of_band[.!isnan.(radiance_of_band)],0.05)\nradiance_q95 = quantile(radiance_of_band[.!isnan.(radiance_of_band)],0.95)\n\nfig = let\n    # Create figure and axis\n    fig = Figure()\n    ax = GeoAxis(fig[1, 1],\n        title = \"HIRS Channel 7\",\n        xlabel = \"longitude\",\n        ylabel = \"latitude\")\n\n    # plot data with color map\n        scatter!(ax, longitude[:], latitude[:],\n        color = radiance_of_band[:], colorrange = (radiance_q05,radiance_q95), markersize = 2)\n\n    # Add colorbar\n    Colorbar(fig[1,2], colorrange = (radiance_q05,radiance_q95))\n\n    # Add coastlines\n    lines!(ax, GeoMakie.coastlines()) \n    fig\nend\n\n(Image: HIRS channel 7)","category":"section"},{"location":"ATOVS/#MHS","page":"ATOVS (AMSU-A, HIRS, MHS)","title":"MHS","text":"The Microwave Humidity Sounder (MHS) is an instrument on the METOP satellites. It measures the earth using 5 microwave channels sensitive to surface temperatures, emissivities, and atmospheric humidity. MHS is one of the three Advanced TIROS Operational Sounder (ATOVS) sensors.\n\nThe level 1B MHS files contain the radiance of the 5 channels. See the MHS Level 1B product page for more information.   This example shows how we compute the brightness temperature of channel 3 and plot it on a map. Note that scene_radiances can also be plotted directly and this will result in a very similar image but with a different color range. \n\nThis example is made using the following packages.\n\n[13f3f980] CairoMakie v0.15.6\n[db073c08] GeoMakie v0.7.15\n\n\nusing MetopDatasets\nusing CairoMakie, GeoMakie, Statistics\n\n# Open the dataset.\npath = \"MHSx_xxx_1B_M03_20250915084851Z_20250915103051Z_N_O_20250915102514Z.nat\"\nds = MetopDataset(path, maskingvalue=NaN);\n\n# select band to plot: 1,2,3,4 or 5\nband_to_plot = 3\n\n# read location\nlatitude = ds[\"earth_location\"][1,:,:]\nlongitude = ds[\"earth_location\"][2,:,:]\n\n# read radiance\nradiance_of_band = ds[\"scene_radiances\"][band_to_plot,:,:]\n\n## convert radiance to brightness temperature.\n\n# get wave number of channel\nmhs_giadr = read_first_record(ds, MetopDatasets.GIADR_MHS_RADIANCE)\nwave_number_cm = get_scaled(mhs_giadr, \"central_wavenumber_h$(band_to_plot)\")\n\n# covert wave number from cm^-1 to m^-1\nwave_number_SI = 10.0^2 * wave_number_cm\n\n# covert radiance from mW/m2/sr/cm-1 to W/m2/sr/m-1\nradiance_SI = radiance_of_band * 10^(-5)\n\nT_brightness_uncorrected = brightness_temperature.(radiance_SI, wave_number_SI)\n\n# Apply linear corrections to the brightness temperature\na_correction = get_scaled(mhs_giadr, \"temperature_h$(band_to_plot)_intercept\")\nb_correction = get_scaled(mhs_giadr, \"temperature_h$(band_to_plot)_slope\")\nT_brightness = a_correction .+ T_brightness_uncorrected .* b_correction\n\n# Plot the correct brightness temperature\nT_brightness_q05 = quantile(T_brightness[:],0.05)\nT_brightness_q95 = quantile(T_brightness[:],0.95)\n\nfig = let\n    # Create figure and axis\n    fig = Figure()\n    ax = GeoAxis(fig[1, 1],\n        title = \"MHS band: H$(band_to_plot)\",\n        xlabel = \"longitude\",\n        ylabel = \"latitude\")\n\n    # plot data with color map\n    scatter!(ax, longitude[:], latitude[:],\n        color = T_brightness[:], colorrange = (T_brightness_q05,T_brightness_q95), markersize = 1)\n\n    # Add colorbar\n    Colorbar(fig[1,2], colorrange = (T_brightness_q05,T_brightness_q95), label=\"K\")\n\n    # Add coastlines\n    lines!(ax, GeoMakie.coastlines()) \n    fig\nend\n\n(Image: MHS Brightness temperature) The plot shows the brightness temperature for the MHS H3 channel (183.311 GHz) observed during an orbit.","category":"section"},{"location":"MetopDataset/#MetopDataset","page":"MetopDataset","title":"MetopDataset","text":"","category":"section"},{"location":"MetopDataset/#Keys,-attributes-and-dimensions.","page":"MetopDataset","title":"Keys, attributes and dimensions.","text":"These methods can help to explore the dataset without printing out everything. \n\nUse keys list the names of all variables without meta data\n\n@show keys(ds)\n\n# loop over all variables\nfor (varname,var) in ds\n    # all variables\n    @show (varname,size(var))\nend\n\nAccess the attributes via the .attrib\n\n@show ds.attrib\n\n# attributes of a variable\nexample_var_name = keys(ds)[end]\nexample_var = ds[example_var_name]\n@show example_var.attrib\n\nAccess the dimensions via the .dim and dimnames\n\n@show ds.dim\n\n# attributes of a variable\nexample_var_name = keys(ds)[end]\nexample_var = ds[example_var_name]\n@show dimnames(example_var)\n\nNote that MetopDataset is not implement any groups. Hence isempty(ds.group) is always true.","category":"section"},{"location":"MetopDataset/#Auto-conversion-and-native-types","page":"MetopDataset","title":"Auto conversion and native types","text":"The Metop native binary formats uses some custom data types. Theres are converted to standard netCDF compatible types by default. This conversion can be disable with the keyword argument auto_convert=false. Here is an example\n\nds = MetopDataset(\"IASI_xxx_1C_M01_20240925202059Z_20240925220258Z_N_O_20240925211316Z.nat\")\n\nfunction show_example(ds, var_name)\n    val = ds[var_name][1]\n    @show var_name\n    @show typeof(val)\n    @show val\n    println()\nend\n\n\nMetopDataset(iasi_file, auto_convert=false) do ds\n    println(\"With auto_convert=false\")\n    println()\n    show_example(ds,\"record_start_time\");\n    show_example(ds,\"gepsiasimode\");\n    show_example(ds,\"gepslociasiavhrr_iasi\");\nend\n\nOutput\n\nWith auto_convert=false\n\nvar_name = \"record_start_time\"\ntypeof(val) = MetopDatasets.ShortCdsTime\nval = MetopDatasets.ShortCdsTime(0x234a, 0x045dd976)\n\nvar_name = \"gepsiasimode\"\ntypeof(val) = MetopDatasets.BitString{4}\nval = 00000000000000000000000010100001\n\n\nvar_name = \"gepslociasiavhrr_iasi\"\ntypeof(val) = MetopDatasets.VInteger{Int32}\nval = MetopDatasets.VInteger{Int32}(6, -1965000000)\n\nIf we run the same example with auto convert on.\n\nMetopDataset(iasi_file, auto_convert=true) do ds\n    println(\"With auto_convert=true\")\n    println()\n    show_example(ds,\"record_start_time\");\n    show_example(ds,\"gepsiasimode\");\n    show_example(ds,\"gepslociasiavhrr_iasi\");\nend\n\nOutput\n\nWith auto_convert=true\n\nvar_name = \"record_start_time\"\ntypeof(val) = Dates.DateTime\nval = Dates.DateTime(\"2024-09-25T20:20:59.382\")\n\nvar_name = \"gepsiasimode\"\ntypeof(val) = UInt32\nval = 0x000000a1\n\nvar_name = \"gepslociasiavhrr_iasi\"\ntypeof(val) = Float64\nval = -1965.0\n\nNote that the auto_convert argument also controls if the IASI L1 spectrum \"gs1cspect\" is automatically scaled. Multiple scale factors are needed to scale the spectrum and therefore the scaling of the spectrum is handled different from other variables. The spectrum is automatically scaled to Float32 to save memory. Use the high_precision=true argument to change this to Float64.","category":"section"},{"location":"MetopDataset/#Missing-values","page":"MetopDataset","title":"Missing values","text":"Note that the datasets can contain missing values. This is especially true for product formats with flexible dimensions like the IASI L2 products. Here is an example.\n\nusing MetopDatasets\nds = MetopDataset(\"IASI_SND_02_M01_20241215173256Z_20241215173552Z_N_C_20241215182326Z\");\n\nds[\"atmospheric_temperature\"][:,:,6]\n\nOutput\n\n101×120 Matrix{Union{Missing, Float64}}:    \n 190.85      189.27      …  missing  missing\n 195.62      193.93         missing  missing     \n 204.47      202.59         missing  missing     \n 212.82      210.87         missing  missing     \n   ⋮                     ⋱\n    missing     missing     missing  missing     \n    missing     missing     missing  missing     \n    missing     missing  …  missing  missing  \n\nHere the output variable is Union{Missing, Float64} which can be difficult to work with. Sometimes it can be and advantage to replace the missing values with NaN values. This can be done on the variable level.\n\nvar_no_missing = cfvariable(ds, \"atmospheric_temperature\", maskingvalue = NaN)\nvar_no_missing[:,:,6]\n\nOutput\n\n101×120 Matrix{Float64}:\n 190.85  189.27  189.0   …  NaN  NaN  NaN  NaN   \n 195.62  193.93  193.69     NaN  NaN  NaN  NaN   \n 204.47  202.59  202.49     NaN  NaN  NaN  NaN   \n 212.82  210.87  210.99     NaN  NaN  NaN  NaN   \n   ⋮                     ⋱\n NaN     NaN     NaN        NaN  NaN  NaN  NaN   \n NaN     NaN     NaN        NaN  NaN  NaN  NaN   \n NaN     NaN     NaN     …  NaN  NaN  NaN  NaN\n\nNote that this is not recommend for integer fields since it results in an automatic conversion to float. This is especially and issue in the cases where the integer value is a representation of an underlying bit string.\n\nvar_temp_error = cfvariable(ds, \"temperature_error\", maskingvalue = NaN)\n\nval_as_scalar = var_temp_error[1,1,1]\nval_as_array = var_temp_error[1:1,1,1]\n\n@show val_as_scalar, bitstring(val_as_scalar);\n@show val_as_array, bitstring.(val_as_array); #wrong bitstring due to conversion\n\nOutput\n\n(val_as_scalar, bitstring(val_as_scalar)) = (0x4277d0a4, \"01000010011101111101000010100100\")\n(val_as_array, bitstring.(val_as_array)) = ([1.115148452e9], [\"0100000111010000100111011111010000101001000000000000000000000000\"])\n\nIt is also possible to set the maskingvalue for an entire dataset. This is convenient but can lead to issues regarding integers as illustrated above. Here is an example:\n\nds_no_missing = MetopDataset(\"IASI_SND_02_M01_20241215173256Z_20241215173552Z_N_C_20241215182326Z\", maskingvalue = NaN);\nds_no_missing[\"atmospheric_temperature\"][:,:,6]\n\nOutput\n\n101×120 Matrix{Float64}:\n 190.85  189.27  189.0   …  NaN  NaN  NaN  NaN   \n 195.62  193.93  193.69     NaN  NaN  NaN  NaN   \n 204.47  202.59  202.49     NaN  NaN  NaN  NaN   \n 212.82  210.87  210.99     NaN  NaN  NaN  NaN   \n   ⋮                     ⋱\n NaN     NaN     NaN        NaN  NaN  NaN  NaN   \n NaN     NaN     NaN        NaN  NaN  NaN  NaN   \n NaN     NaN     NaN     …  NaN  NaN  NaN  NaN","category":"section"},{"location":"MetopDataset/#MetopDatasets.MetopDataset","page":"MetopDataset","title":"MetopDatasets.MetopDataset","text":"MetopDataset(file_path::AbstractString; auto_convert::Bool = true, high_precision::Bool=false, maskingvalue = missing)\nMetopDataset(file_pointer::IO; auto_convert::Bool = true, high_precision::Bool=false, maskingvalue = missing)\nMetopDataset(f::Function, file_path::AbstractString; auto_convert::Bool = true, high_precision::Bool=false, maskingvalue = missing)\n\nLoad a MetopDataset from a Metop Native binary file or from a IO to a Native binary file. Only the meta data is loaded upon creation and all variables are lazy loaded.  The variables corresponds to the different fields of the data records in the file. The attributes have all the information from the main product header in the file.\n\nauto_convert=true will automatically convert MetopDatasets specific types such as VInteger to common netCDF complaint types such as Float64. This will also automatically scale variable where the  scaling can't be expressed through a simple scale factor e.g. the IASI spectrum where different bands of  the spectrum have different scaling factors.\n\nSelected fields are converted to Float32 to save memory. Normally Float32 is more than sufficient to represent the instrument accuracy.  Setting high_precision=true will in some case convert these variables to Float64. \n\nmaskingvalue = NaN will replace missing values with NaN. This normally floats but can create issues for integers. See documentation page for more information.\n\nExample\n\njulia> file_path = \"test/testData/ASCA_SZR_1B_M03_20230329063300Z_20230329063558Z_N_C_20230329081417Z\"\njulia> ds = MetopDataset(file_path);\njulia>\njulia> # display metadata of a variable\njulia> ds[\"latitude\"]\nlatitude (82 × 96)\n  Datatype:    Union{Missing, Float64} (Int32)\n  Dimensions:  xtrack × atrack\n  Attributes:\n   description          = Latitude (-90 to 90 deg)\n   missing_value        = Int32[-2147483648]\n   scale_factor         = 1.0e-6\njulia>\njulia> # load a subset of a variable  \njulia> lat_subset = ds[\"latitude\"][1:2,1:3] # load a small subset of latitudes.\n2×3 Matrix{Union{Missing,Float64}}:\n    -33.7308  -33.8399  -33.949\n    -33.7139  -33.823   -33.9322\njulia>\njulia> # load entire variable  \njulia> lat = ds[\"latitude\"][:,:]\njulia>\njulia> # close data set\njulia> close(ds);\n\n\n\n\n\n","category":"type"},{"location":"ASCAT/#ASCAT","page":"ASCAT","title":"ASCAT","text":"The Advanced Scatterometer (ASCAT) is an instrument on the METOP satellites. It is a fixed beam C-band scatterometer with 6 antenna beams used to retrieve wind vectors over the ocean and soil moisture over the land. The level 1 products are normalised backscatter coefficients (sigma0) that the instrument measures directly. The level 2 products are soil moisture and wind vectors derived from the backscatter. The wind vector product does not use the native binary format so they are not described further here. It should be noted that the winds are available as NetCDF. For more information see ASCAT User Guide\n\nAll data used in examples are available from EUMETSAT data store","category":"section"},{"location":"ASCAT/#SZF-beam-statistics","page":"ASCAT","title":"SZF beam statistics","text":"The level 1B SZF files contain full resolution backscatter from the 6 antenna beams. See the ASCAT level 1B SZF product page for more information.   This example shows how we can get the 5% and 95% quantile of the backscatter from each beam only considering the observations with no flags. It should be noted that observations over land are are flagged with a land-flag so theses statistics only consider oceans.\n\nRead and inspect the variables:\n\nusing MetopDatasets, Statistics\nds = MetopDataset(\"ASCA_SZF_1B_M03_20241217091500Z_20241217105659Z_N_O_20241217105652Z.nat\")\n\n# Read arrays immediately\nbeam_numbers = Array(ds[\"beam_number\"])\nsigma0 = Array(ds[\"sigma0_full\"])\nflags = Array(ds[\"flagfield\"])\n\n@show size(beam_numbers)\n@show size(sigma0)\n@show size(flags)\n\nno_flags = flags .== 0 \nprintln(\"Number of observations with no flag: \", sum(no_flags))\n\nREPL output:\n\nsize(beam_numbers) = (43236,)\nsize(sigma0) = (192, 43236)  \nsize(flags) = (192, 43236)\nNumber of observations with no flag: 5948489\n\nWe can see that beam_numbers only have 1 dimension but sigma0 and flags have two. This is because there is only one beam number per data record but each data record contain a line with 192 observations across the swath.  Printing the quantiles for each beam.\n\nfor i in 1:6 # same as `i in sort(unique(beam_numbers))`\n    in_beam = beam_numbers .== i\n    sigma0_beam = sigma0[:, in_beam]\n    no_flags_beam = no_flags[:, in_beam]\n\n    sigma_q05 = quantile(sigma0_beam[no_flags_beam],0.05)\n    sigma_q95 = quantile(sigma0_beam[no_flags_beam],0.95)\n\n    rounded_range = round.((sigma_q05,sigma_q95); digits=2) \n\n    println(\"Beam: \", i, \", Sigma0 (q05,q95) range: \", rounded_range )\nend\n\nREPL output:\n\nBeam: 1, Sigma0 (q05,q95) range: (-29.84, -12.31)\nBeam: 2, Sigma0 (q05,q95) range: (-27.22, -5.63)\nBeam: 3, Sigma0 (q05,q95) range: (-29.94, -12.76)\nBeam: 4, Sigma0 (q05,q95) range: (-28.75, -12.96)\nBeam: 5, Sigma0 (q05,q95) range: (-25.5, -5.2)\nBeam: 6, Sigma0 (q05,q95) range: (-28.4, -12.02)\n\nWe can now see the sigma0 quintile ranges for each beam.","category":"section"},{"location":"ASCAT/#SZR-and-SZO-plot","page":"ASCAT","title":"SZR and SZO plot","text":"The level 1B SZR files contain backscatter values from the 6 ASCAT beams, resampled to a common 12.5 x 12.5 km grid. There are three beams imaging each side of the satellite so this results in 3 backscatter measurements for each grid point. The level 1B SZO files are identical but resampled to a 25 x 25 km grid instead. See ASCAT level 1B SZR product page and ASCAT level 1B SZO product page for more information.\n\nThese examples will work to both plot SZR and SZO data. The examples are made using the following packages.\n\n[13f3f980] CairoMakie v0.12.16\n[db073c08] GeoMakie v0.7.9\n\nNote that the plot can become interactive by replacing CarioMakie with GLMakie. See Makie documentation for more information on plotting.","category":"section"},{"location":"ASCAT/#Global-plot-of-SZR-or-SZO","page":"ASCAT","title":"Global plot of SZR or SZO","text":"This example plots the backscatter from and entire orbit. The backscatter is just plotted for one beam direction. \n\nusing MetopDatasets\nusing CairoMakie, GeoMakie, Statistics\n\n# Open the dataset\nds = MetopDataset(\"ASCA_SZR_1B_M01_20241217081500Z_20241217095658Z_N_O_20241217090832Z.nat\", maskingvalue=NaN);\n\n# Select which beam to plot \nbeam_names = [\"fore-beam\", \"mid-beam\", \"aft-beam\"]\nbeam_index = 3\n\n# read variables for beam\nlatitude = Array(ds[\"latitude\"])\nlongitude = Array(ds[\"longitude\"])\nsigma0 = ds[\"sigma0_trip\"][beam_index,:,:]\nusable_flag = ds[\"f_usable\"][beam_index,:,:]\n\n# change longitude to be -180 to 180\nlongitude[longitude .> 180] .-= 360\n\n# check flags\nusable = usable_flag .!= 2\n\n# get sigma0 ranges\nsigma_q05 = quantile(sigma0[usable],0.05)\nsigma_q95 = quantile(sigma0[usable],0.95)\n\n# plot the data\nfig = let\n\n    # Create figure and axis\n    fig = Figure()\n    ax = GeoAxis(fig[1, 1],\n        title = \"Backscatter for \" * beam_names[beam_index],\n        xlabel = \"longitude\",\n        ylabel = \"latitude\")\n\n    # plot \"good\" and \"usable\" data with color map\n    scatter!(ax, longitude[usable], latitude[usable],\n        color = sigma0[usable], colorrange = (sigma_q05,sigma_q95), markersize = 1)\n\n    # plot \"bad\" data as red\n    scatter!(ax, longitude[.!usable], latitude[.!usable],\n        color = :red, markersize = 1)\n\n    # Add colorbar\n    Colorbar(fig[1,2], colorrange = (sigma_q05,sigma_q95), label=\"dB\")\n\n    # Add coastlines\n    lines!(ax, GeoMakie.coastlines()) \n    fig\nend\n\n(Image: Global SZR plot)\n\nThe plot shows the left and right swath ASCAT mapped for an orbit. ","category":"section"},{"location":"ASCAT/#Plotting-a-subset-of-SZR-or-SZO","page":"ASCAT","title":"Plotting a subset of SZR or SZO","text":"This example shows how to plot the backscatter for a small subset of the SZR product.\n\nusing MetopDatasets\nusing CairoMakie, GeoMakie, Statistics\n\nds = MetopDataset(\"ASCA_SZR_1B_M01_20241217081500Z_20241217095658Z_N_O_20241217090832Z.nat\", maskingvalue=NaN);\n\n# Select subset record subset to plot\nrecord_subset = 150:350\n\n# define the two swaths. \ngrid_nodes = ds.dim[\"xtrack\"]\nswath_width = div(grid_nodes,2)\nleft_swath = 1:swath_width\nright_swath = (swath_width+1):grid_nodes\n\n# read variables for right_swath of the subset.\nlatitude = ds[\"latitude\"][right_swath, record_subset]\nlongitude = ds[\"longitude\"][right_swath, record_subset]\nsigma0 = ds[\"sigma0_trip\"][:, right_swath, record_subset]\nusable_flag = ds[\"f_usable\"][:, right_swath, record_subset]\n\n# change longitude to be -180 to 180\nlongitude[longitude .> 180] .-= 360\n\n# check flags\nusable = usable_flag .!= 2\n\n# get sigma0 ranges\nsigma_q05 = quantile(sigma0[usable],0.05)\nsigma_q95 = quantile(sigma0[usable],0.95)\n\n# plot the data\nbeam_names = [\"fore-beam\", \"mid-beam\", \"aft-beam\"]\nfig = let    \n    fig = Figure()\n\n    # plot each beam\n    for i in 1:3\n        sigma_i = sigma0[i,:,:]\n        usable_i = usable[i,:,:]\n\n        # Create new axis\n        ax = GeoAxis(fig[1, i],\n            title = beam_names[i],\n            xlabel = \"longitude\",\n            ylabel = \"latitude\",\n            limits = (extrema(longitude), extrema(latitude))\n            )\n\n        # plot \"good\" and \"usable\" data with color map\n        scatter!(ax, longitude[usable_i], latitude[usable_i],\n            color = sigma_i[usable_i], colorrange = (sigma_q05,sigma_q95), markersize = 6)\n        \n        # plot \"bad\" data as red\n        scatter!(ax, longitude[.!usable_i], latitude[.!usable_i],\n            color = :red, markersize = 6)\n\n        # add coastlines\n        lines!(ax, GeoMakie.coastlines(), color=:black) \n    end\n\n    # add colorbar\n    Colorbar(fig[1,4], colorrange = (sigma_q05,sigma_q95), label=\"dB\")\n\n    fig\nend\n\n(Image: Subset SZR plot)\n\nThe subset shows the measured backscatter from the right swath over the mediterranean and across Italy. The red spots shows the measurements flagged as \"bad\". This is probably caused by radio frequency interference from ground equipment resulting in a low signal-to-noise ratio.","category":"section"},{"location":"ASCAT/#Soil-moisture-example","page":"ASCAT","title":"Soil moisture example","text":"The ASCAT Level 2 SMR product contains relative soil moisture on a 12.5 x 12.5 km grid. The SMO product is identical but resampled to a 25 x 25 km grid instead. See ASCAT level 2 SMR product page and ASCAT level 2 SMO product page for more information.\n\nThese examples will work to plot both SMR and SMO data. The examples are made using the following packages.\n\n[13f3f980] CairoMakie v0.12.16\n[db073c08] GeoMakie v0.7.9","category":"section"},{"location":"ASCAT/#Plotting-a-subset-of-SMR-or-SMO","page":"ASCAT","title":"Plotting a subset of SMR or SMO","text":"This example shows how to plot the soil moisture for from a SMR or SMO product.\n\nusing MetopDatasets\nusing CairoMakie, GeoMakie, Dates\n\nds = MetopDataset(\"ASCA_SMR_02_M01_20241217081500Z_20241217095658Z_N_O_20241217090845Z.nat\", maskingvalue=NaN);\n\n# Select subset record subset to plot\nrecord_subset = 150:350\n\n# define the two swaths. \ngrid_nodes = ds.dim[\"xtrack\"]\nswath_width = div(grid_nodes,2)\nleft_swath = 1:swath_width\nright_swath = (swath_width+1):grid_nodes\n\n# get sensing date\nsensing_date = Date(DateTime(ds.attrib[\"sensing_start\"]))\n\n# read variables for right_swath of the subset.\nlatitude = ds[\"latitude\"][right_swath, record_subset]\nlongitude = ds[\"longitude\"][right_swath, record_subset]\nsoil_moisture = ds[\"soil_moisture\"][right_swath, record_subset]\n\n# change longitude to be -180 to 180\nlongitude[longitude .> 180] .-= 360\n\nfig = let    \n    fig = Figure()\n\n    # Create new axis\n    ax = GeoAxis(fig[1, 1],\n        title = \"Soil moisture $(sensing_date)\",\n        xlabel = \"longitude\",\n        ylabel = \"latitude\",\n        limits = (extrema(longitude), extrema(latitude))\n        )\n\n    # plot with scatter\n    scatter!(ax, longitude[:], latitude[:], color=soil_moisture[:], colorrange=(0.0,100.0))\n\n    # add coastlines\n    lines!(ax, GeoMakie.coastlines(), color=:black) \n \n    # add colorbar\n    Colorbar(fig[1,2], colorrange = (0.0,100.0), label=\"soil moisture %\")\n\n    fig\nend\n\n(Image: Subset SZR plot) The plot shows the retrieved soil moisture. The filtering on flags in this example is very rough. It might be good to have a close look at the individual flag variables depending on the application.","category":"section"},{"location":"python/#Use-with-Python","page":"Use with Python","title":"Use with Python","text":"","category":"section"},{"location":"python/#MetopPy-(Recommended)","page":"Use with Python","title":"MetopPy (Recommended)","text":"A python wrapper around MetopDataset.jl. MetopPy can simply be installed using pip\n\npip install metoppy\n\nVisit the MetopPy repository for more information and examples.","category":"section"},{"location":"python/#Use-with-juliacall-(Advanced)","page":"Use with Python","title":"Use with juliacall (Advanced)","text":"This guide gives a basic example of using MetopDatasets in python via juliacall. For more information see juliacall documentation for more information.","category":"section"},{"location":"python/#Installation","page":"Use with Python","title":"Installation","text":"The installation part just needs to be run once.","category":"section"},{"location":"python/#Prerequisites","page":"Use with Python","title":"Prerequisites","text":"Julia, Python and Pip all needs to be installed on the machine. This can be checked with the following bash commands.\n\npython --version\njulia --version\npip --version\n\nThis guide is tested with the following versions \n\nPython 3.12.8\njulia version 1.11.1\npip 24.2","category":"section"},{"location":"python/#Installing-python-packages","page":"Use with Python","title":"Installing python packages","text":"We use pip to install juliacall and numpy. We need juliacall to interface with julia and numpy is just needed to demonstrate compatibility with numpy arrays.\n\npip install juliacall\npip install numpy","category":"section"},{"location":"python/#Installing-MetopDatasets.jl","page":"Use with Python","title":"Installing MetopDatasets.jl","text":"Install MetopDatasets.jl via juliacall by running the following Python code.\n\nimport juliacall\n# make separate module\njl = juliacall.newmodule(\"MetopDatasetsPy\") \njl.seval(\"import Pkg\")\njl.Pkg.add(\"MetopDatasets\")","category":"section"},{"location":"python/#Example","page":"Use with Python","title":"Example","text":"You are now ready to use MetopDatasets.jl in python. Below are snippets of python code showing a simple example.","category":"section"},{"location":"python/#Loading-MetopDatasets-in-the-python-session.","page":"Use with Python","title":"Loading MetopDatasets in the python session.","text":"import juliacall\nimport numpy as np\njl = juliacall.newmodule(\"MetopDatasetsPy\")\njl.seval(\"using MetopDatasets\")","category":"section"},{"location":"python/#Reading-a-dataset","page":"Use with Python","title":"Reading a dataset","text":"The dataset is simply read with MetopDataset. Only the metadata is read straight away. The variables can be read on demand.\n\ntest_file = \"/tcenas/home/lupemba/Documents/data/IASI_xxx_1C_M01_20240819103856Z_20240819104152Z_N_C_20240819112911Z\"\nds = jl.MetopDataset(test_file, maskingvalue=float('nan'))\n\nThe dataset has a method equivalent to __repr__ so the structure of the dataset can be shown easily. The julia keys function can be used to only list variable names.\n\njl.keys(ds)\n\nThe individual variables can also be inspected. \n\nds[\"gs1cspect\"]\n\nThe individual variables can be loaded and used like np.arrays. The record time is a small variable so we can load it all into memory.\n\nrecord_start_time = jl.Array(ds[\"record_start_time\"])\nprint(\"record_start_time\")\nprint(np.shape(record_start_time))\nprint(np.min(record_start_time))\nprint(np.max(record_start_time))\n\nIt is also possible to just load a slice of a variable. The size of the IASI spectra of an entire orbit is around 2 GB but we can easily load a subset into memory. \n\nspectra_index = 2300\nsingle_channel_slice = ds[\"gs1cspect\"][spectra_index,:,:,0:10]\nprint(\"single_channel_slice\")\nprint(np.shape(single_channel_slice))\nprint(np.mean(single_channel_slice))","category":"section"},{"location":"python/#Alternative-packages","page":"Use with Python","title":"Alternative packages","text":"For python alternatives see  Eugene (documentation) or Satpy (supports many EUMETSAT formats but only limited support for Metop). ","category":"section"},{"location":"full_api/#Public-functions-and-types","page":"Full API","title":"Public functions and types","text":"","category":"section"},{"location":"full_api/#Internal-functions-and-types","page":"Full API","title":"Internal functions and types","text":"","category":"section"},{"location":"full_api/#MetopDatasets.brightness_temperature-Union{Tuple{T}, Tuple{T, Real}, Tuple{T, Real, Any}} where T<:Real","page":"Full API","title":"MetopDatasets.brightness_temperature","text":"brightness_temperature(I::T, wavenumber::Real, default=T(NaN)) where T <: Real\n\nConverting the IASI L1C spectrum from radiances to brightness temperature. Note that the wavenumber must in m^-1 and I in W/m2/sr/m-1\n\nExample\n\njulia> file_path = \"test/testData/IASI_xxx_1C_M01_20240819103856Z_20240819104152Z_N_C_20240819112911Z\"\njulia> ds = MetopDataset(file_path);\njulia> spectrum = ds[\"gs1cspect\"][:,1,1,1]\njulia> wavenumber = ds[\"spectra_wavenumber\"][:, 1]\njulia> # convert from radiances to brightness temperature\njulia> T_B = brightness_temperature.(spectrum, wavenumber)\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.data_record_type-Tuple{MetopDatasets.MainProductHeader}","page":"Full API","title":"MetopDatasets.data_record_type","text":"data_record_type(header::MainProductHeader)::Type\n\nGet the type of data record based on the main product header\n\nExample\n\njulia> file_pointer = open(\"ASCA_SZO_1B_M03_20230329063300Z_20230329063556Z_N_C_20230329081417Z\")\njulia> main_header = MetopDatasets.native_read(file_pointer, MainProductHeader)\njulia> data_record_type(main_header)\nASCA_SZO_1B_V13\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.get_scaled-Union{Tuple{T}, Tuple{T, Union{AbstractString, Symbol}}} where T<:MetopDatasets.BinaryRecord","page":"Full API","title":"MetopDatasets.get_scaled","text":"get_scaled(record::T, field::Union{AbstractString,Symbol}) where T <: BinaryRecord\n\nGet the property from a data record type and apply scale factor if defined.\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.get_test_data_artifact-Tuple{}","page":"Full API","title":"MetopDatasets.get_test_data_artifact","text":"get_test_data_artifact()\n\nReturns path to folder storing reduced test data. Note that the test data is downloaded from https://github.com/eumetsat/test-data-MetopDatasets the first time the function it called.\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.read_first_record-Tuple{Any, Any}","page":"Full API","title":"MetopDatasets.read_first_record","text":"read_first_record(source, record_type)::record_type\n\nA simple alias for read_single_record(source, record_type, 1)\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.read_single_record-Tuple{MetopDataset, Type{<:MetopDatasets.Record}, Integer}","page":"Full API","title":"MetopDatasets.read_single_record","text":"read_single_record(ds::MetopDataset, record_type::Type{<:Record})\nread_single_record(file_pointer::IO, record_type::Type{<:Record})\nread_single_record(file_path::AbstractString, record_type::Type{<:Record})\n\nRead the n'th record of type record_type from the dataset. This can be used to access records that are  not directly exposed through the MetopDataset interface.\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.record_struct_expression-Tuple{Any, Any}","page":"Full API","title":"MetopDatasets.record_struct_expression","text":"record_struct_expression(file_name, record_type)\n\nFunction to autogenerate Struct code based on a CSV file.  Also autogenerates get_description and get_scale_factor method for Struct. Use it together with eval.\n\nExample\n\njulia> eval(record_struct_expression(joinpath(@__DIR__, \"TEST_FORmaT.csv\"), DataRecord))\njulia> TEST_FORMAT <: DataRecord\ntrue\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.scale_iasi_spectrum-Tuple{Any, MetopDatasets.GIADR_IASI_XXX_1C, OrdinalRange}","page":"Full API","title":"MetopDatasets.scale_iasi_spectrum","text":"scale_iasi_spectrum(spec_raw, giadr::GIADR_IASI_XXX_1C; high_precision = false)\nscale_iasi_spectrum(spec_raw, giadr::GIADR_IASI_XXX_1C, channel_range::OrdinalRange; high_precision = false)\n\nScaling the IASI L1C spectrum using the giadr record information. The channel_range is needed if only a  subset of the raw spectrum is passed to the function.  Setting high_precision=true will convert to Float64 instead of Float32.  Note that the end part of the  ds[\"gs1cspect\"] does not have any scale factors. Here the spectrum is just  filled with 0.0.\n\nExample\n\njulia> file_path = \"test/testData/IASI_xxx_1C_M01_20240819103856Z_20240819104152Z_N_C_20240819112911Z\"\njulia> ds = MetopDataset(file_path, auto_convert = false);\njulia> giadr = MetopDatasets.read_first_record(ds, MetopDatasets.GIADR_IASI_XXX_1C_V11)\njulia> # Scale full spectrum.\njulia> scaled_spectrum = MetopDatasets.scale_iasi_spectrum(ds[\"gs1cspect\"], giadr)\njulia> # Scale subset of spectrum.\njulia> scaled_spectrum_subset = MetopDatasets.scale_iasi_spectrum(ds[\"gs1cspect\"][10:20,:,:,:], giadr, 10:20)\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.AbstractMetopDiskArray","page":"Full API","title":"MetopDatasets.AbstractMetopDiskArray","text":"AbstractMetopDiskArray{T, N} <: DiskArrays.AbstractDiskArray{T, N}\n\nIn most cases MetopDiskArray is used but AbstractMetopDiskArray allows defining additional DiskArray types to handle special corner cases. \n\n\n\n\n\n","category":"type"},{"location":"full_api/#MetopDatasets.FixedRecordLayout","page":"Full API","title":"MetopDatasets.FixedRecordLayout","text":"FixedRecordLayout\n\nUsed to store the record layout of fixed size data records in a Native metop files.\n\n\n\n\n\n","category":"type"},{"location":"full_api/#MetopDatasets.MetopDataset-Tuple{AbstractString}","page":"Full API","title":"MetopDatasets.MetopDataset","text":"MetopDataset(file_path::AbstractString; auto_convert::Bool = true, high_precision::Bool=false, maskingvalue = missing)\nMetopDataset(file_pointer::IO; auto_convert::Bool = true, high_precision::Bool=false, maskingvalue = missing)\nMetopDataset(f::Function, file_path::AbstractString; auto_convert::Bool = true, high_precision::Bool=false, maskingvalue = missing)\n\nLoad a MetopDataset from a Metop Native binary file or from a IO to a Native binary file. Only the meta data is loaded upon creation and all variables are lazy loaded.  The variables corresponds to the different fields of the data records in the file. The attributes have all the information from the main product header in the file.\n\nauto_convert=true will automatically convert MetopDatasets specific types such as VInteger to common netCDF complaint types such as Float64. This will also automatically scale variable where the  scaling can't be expressed through a simple scale factor e.g. the IASI spectrum where different bands of  the spectrum have different scaling factors.\n\nSelected fields are converted to Float32 to save memory. Normally Float32 is more than sufficient to represent the instrument accuracy.  Setting high_precision=true will in some case convert these variables to Float64. \n\nmaskingvalue = NaN will replace missing values with NaN. This normally floats but can create issues for integers. See documentation page for more information.\n\nExample\n\njulia> file_path = \"test/testData/ASCA_SZR_1B_M03_20230329063300Z_20230329063558Z_N_C_20230329081417Z\"\njulia> ds = MetopDataset(file_path);\njulia>\njulia> # display metadata of a variable\njulia> ds[\"latitude\"]\nlatitude (82 × 96)\n  Datatype:    Union{Missing, Float64} (Int32)\n  Dimensions:  xtrack × atrack\n  Attributes:\n   description          = Latitude (-90 to 90 deg)\n   missing_value        = Int32[-2147483648]\n   scale_factor         = 1.0e-6\njulia>\njulia> # load a subset of a variable  \njulia> lat_subset = ds[\"latitude\"][1:2,1:3] # load a small subset of latitudes.\n2×3 Matrix{Union{Missing,Float64}}:\n    -33.7308  -33.8399  -33.949\n    -33.7139  -33.823   -33.9322\njulia>\njulia> # load entire variable  \njulia> lat = ds[\"latitude\"][:,:]\njulia>\njulia> # close data set\njulia> close(ds);\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.MetopDiskArray","page":"Full API","title":"MetopDatasets.MetopDiskArray","text":"MetopDiskArray{T, N} <: AbstractMetopDiskArray{T, N}\n\nStruct to handle  lazy loading of a variable in a Metop product. The raw types in the product is mapped without any  scaling. Auto conversion can be enabled for RecordSubType e.g. converting VInteger to Float64.\n\n\n\n\n\n","category":"type"},{"location":"full_api/#MetopDatasets.MetopDiskArray-Tuple{IOStream, Vector{<:MetopDatasets.RecordLayout}, Symbol}","page":"Full API","title":"MetopDatasets.MetopDiskArray","text":"MetopDiskArray(file_pointer::IOStream,\n    record_layouts::Vector{FixedRecordLayout},\n    field_name::Symbol; auto_convert = true) -> MetopDiskArray\n\nConstructor for MetopDiskArray that compute additional fields. auto_convert = true will automatically convert custom RecordSubType to commonly used data types e.g. converting VInteger to Float64.\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.MetopVariable","page":"Full API","title":"MetopDatasets.MetopVariable","text":"MetopVariable{T, N, R <: DataRecord, A <: AbstractArray{T, N}} <: CommonDataModel.AbstractVariable{T, N}\n\nMetopVariable wraps an AbstractArray so it can be used with MetopDataset.  The data array is normally AbstractMetopDiskArray.\n\n\n\n\n\n","category":"type"},{"location":"full_api/#MetopDatasets._get_data_record_layouts-Tuple{Vector{MetopDatasets.InternalPointerRecord}, Integer, Type{<:MetopDatasets.DataRecord}}","page":"Full API","title":"MetopDatasets._get_data_record_layouts","text":"_get_data_record_layouts(internal_pointer_records::Vector{InternalPointerRecord},\n    total_file_size::Integer, record_type::Type{<:DataRecord})::Vector{FixedRecordLayout}\n\nCompute the record_layouts\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets._get_flexible_dims_file-Tuple{IO, Type{<:MetopDatasets.BinaryRecord}}","page":"Full API","title":"MetopDatasets._get_flexible_dims_file","text":"_get_flexible_dims_file(file_pointer::IO, T::Type{<:BinaryRecord})\n\nRead the flexible types from a product. Note that the IO position is not changed by calling the function\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.construct_disk_array-Tuple{IOStream, Vector{<:MetopDatasets.RecordLayout}, Symbol}","page":"Full API","title":"MetopDatasets.construct_disk_array","text":"construct_disk_array(file_pointer::IOStream,\n    record_layouts::Vector{<:RecordLayout},\n    field_name::Symbol; auto_convert = true)\n\nConstruct a disk array. The type of disk array is automatically determined. The standard type of disk array is MetopDiskArray but there are also other types. FlexibleMetopDiskArray is  returned for fields where the size varies inside the product, eg. IASI L2 \"temperature_error\".\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.fixed_size-Tuple{Type{<:MetopDatasets.BinaryRecord}, Symbol}","page":"Full API","title":"MetopDatasets.fixed_size","text":"fixed_size(T::Type{<:BinaryRecord})::Bool\nfixed_size(T::Type{<:BinaryRecord}, fieldname::Symbol)::Bool\n\nGet if the data record has a binary fixed size. This is often used as a trait via the \"julia Holy Traits Pattern\" fieldname is used to check if a specific field has a fixed binary size.\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.fixed_size_in_file-Tuple{Type{<:MetopDatasets.BinaryRecord}, Symbol}","page":"Full API","title":"MetopDatasets.fixed_size_in_file","text":"fixed_size_in_file(T::Type{<:BinaryRecord}, fieldname::Symbol)::Bool\n\nCheck if the field have a constant size in a product. Return false if the field size can vary within a single file.\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.get_description-Tuple{Type{<:MetopDatasets.BinaryRecord}, Symbol}","page":"Full API","title":"MetopDatasets.get_description","text":"get_description(T::Type{<:BinaryRecord}, field::Symbol)::AbstractString\n\nGet the description for a given field in the BinaryRecord\n\nExample\n\njulia> get_description(ASCA_SZR_1B_V13, :sigma0_trip)\n\"Sigma0 triplet, re-sampled to swath grid, for 3 beams (fore, mid, aft) \"\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.get_dimensions-Tuple{Type{<:MetopDatasets.BinaryRecord}}","page":"Full API","title":"MetopDatasets.get_dimensions","text":"get_dimensions(T::Type{<:BinaryRecord})::OrderedDict{String, <:Integer}\n\nGet the the named dimensions in a BinaryRecord and their length.\n\nExample\n\njulia> get_dimensions(ASCA_SZR_1B_V13)\nOrderedDict{String, Int64} with 2 entries:\n  \"num_band\" => 3\n  \"xtrack\"   => 82\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.get_field_dimensions-Tuple{Type{<:MetopDatasets.BinaryRecord}, Symbol}","page":"Full API","title":"MetopDatasets.get_field_dimensions","text":"get_field_dimensions(T::Type{<:BinaryRecord}, field::Symbol)::Vector{<:AbstractString}\n\nGet the named dimensions of a field in a BinaryRecord\n\nExample\n\njulia> get_field_dimensions(ASCA_SZR_1B_V13, :sigma0_trip)\n[\"num_band\", \"xtrack\"]\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.get_flexible_dim_fields-Tuple{Type{<:MetopDatasets.BinaryRecord}}","page":"Full API","title":"MetopDatasets.get_flexible_dim_fields","text":"get_flexible_dim_fields(T::Type{<:BinaryRecord})::AbstractDict{Symbol,Symbol}\n\nGet a dictionary with field names as key and the corresponding flexible dim as value.  Only fields representing a flexible dim is included. Must be implemented for Records containing  flexible dim values.\n\nExample\n\njulia> get_flexible_dim_fields(IASI_SND_02)\nOrderedDict{Symbol, Symbol} with 4 entries:\n  :co_nbr   => :CO_NBR\n  :o3_nbr   => :O3_NBR\n  :nerr     => :NERR\n  :hno3_nbr => :HNO3_NBR\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.get_missing_value-Tuple{Type{<:MetopDatasets.Record}, Symbol}","page":"Full API","title":"MetopDatasets.get_missing_value","text":"get_missing_value(T::Type{<:Record}, field::Symbol)\n\nGet the value representing missing for the field. Default values are implemented for Integers but  they can be overwritten for specific record types to account for different conventions.\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.get_raw_format_dim-Tuple{Type{<:MetopDatasets.BinaryRecord}, Symbol}","page":"Full API","title":"MetopDatasets.get_raw_format_dim","text":"get_raw_format_dim(T::Type{<:BinaryRecord}, field::Symbol)\n\nGet the dimensions of the field as defined in the record format specification.\n\nExample\n\njulia> get_raw_format_dim(ASCA_SZR_1B_V13, :sigma0_trip)\n(3, 82, 1, 1)\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.get_scale_factor-Tuple{Type{<:MetopDatasets.BinaryRecord}, Symbol}","page":"Full API","title":"MetopDatasets.get_scale_factor","text":"get_scale_factor(T::Type{<:BinaryRecord}, field::Symbol)::Union{Number,Nothing}\n\nget the scale_factor for a given field in the BinaryRecord. The variable can late be scaled from  integer to float by dividing with 10^scale_factor. Returns nothing if no scale factor is set. \n\nExample\n\njulia> get_scale_factor(ASCA_SZR_1B_V13, :sigma0_trip) \n6\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.layout_info_for_disk_array-Tuple{Vector{<:MetopDatasets.RecordLayout}, Symbol}","page":"Full API","title":"MetopDatasets.layout_info_for_disk_array","text":"layout_info_for_disk_array(record_layouts::Vector{<:RecordLayout}, field_name::Symbol)\n\nExtract information need in MetopDiskArray\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.native_read-Tuple{IO, Type}","page":"Full API","title":"MetopDatasets.native_read","text":"native_read(io::IO, T)::T\n\nRead a single object of type T from io to a file in the native Metop format.  Endianness is automatically converted.\n\nExample\n\njulia> file_pointer = open(\"ASCA_SZO_1B_M03_20230329063300Z_20230329063556Z_N_C_20230329081417Z\")\njulia> main_header = MetopDatasets.native_read(file_pointer, MainProductHeader)\njulia> main_header.sensing_start\n2023-03-29T06:33:00\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.native_sizeof-Tuple{Type{<:Tuple}}","page":"Full API","title":"MetopDatasets.native_sizeof","text":"native_sizeof(x)::Integer\n\nThe byte size of the type x in a METOP native product.\n\nExample\n\njulia> native_sizeof(RecordHeader)\n20\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.read_record_layouts-Tuple{IO, MetopDatasets.MainProductHeader}","page":"Full API","title":"MetopDatasets.read_record_layouts","text":"read_record_layouts(file_pointer::IO, main_product_header::MainProductHeader)\n\nRead the appropriate record layout from IO.\n\n\n\n\n\n","category":"method"},{"location":"full_api/#MetopDatasets.DummyRecord","page":"Full API","title":"MetopDatasets.DummyRecord","text":"DummyRecord <:Record\n\nThe Dummy Measurement Data Record is a special case of the MDR. It is a generic record that is used to indicate the location of lost data within any product. One DMDR can replace a contiguous block of lost MDRs\n\n\n\n\n\n","category":"type"},{"location":"full_api/#MetopDatasets.FlexibleMetopDiskArray","page":"Full API","title":"MetopDatasets.FlexibleMetopDiskArray","text":"FlexibleMetopDiskArray{T, N} <: AbstractMetopDiskArray{T, N}\n\nSimilar to MetopDiskArray but able to handle flexible record layout and  fields where the size varies within a single product file. E.g. IASI L2 fields like \"temperature_error\".\n\n\n\n\n\n","category":"type"},{"location":"full_api/#MetopDatasets.FlexibleRecordLayout","page":"Full API","title":"MetopDatasets.FlexibleRecordLayout","text":"FlexibleRecordLayout\n\nUsed to store the record layout of flexible size data records in a Native metop files.\n\n\n\n\n\n","category":"type"},{"location":"full_api/#MetopDatasets.IasiSpectrumDiskArray","page":"Full API","title":"MetopDatasets.IasiSpectrumDiskArray","text":"IasiSpectrumDiskArray{T} <: AbstractMetopDiskArray{T, 4}\n\nThe IasiSpectrumDiskArray is a wrapper around a MetopDiskArray that enables the automatic scaling of the the IASI L1C spectrum using the GIADR_IASI_XXX_1C record information.\n\n\n\n\n\n","category":"type"},{"location":"full_api/#MetopDatasets.IasiWaveNumberDiskArray","page":"Full API","title":"MetopDatasets.IasiWaveNumberDiskArray","text":"IasiWaveNumberDiskArray <: AbstractMetopDiskArray{Float64, 2}\n\nThe IasiWaveNumberDiskArray is a disk array that computes the wavenumber of the IASI spectrum. The  wavenumber is computed using :idefnsfirst1b and :idefspectdwn1b from each data record.\n\n\n\n\n\n","category":"type"},{"location":"full_api/#MetopDatasets.InternalPointerRecord","page":"Full API","title":"MetopDatasets.InternalPointerRecord","text":"InternalPointerRecord <: Record\n\nThe Internal Pointer Records (IPR) specifies the start of each block of records in the file sharing the same record type. This can be used to find the locations of data records or dummy records.\n\n\n\n\n\n","category":"type"},{"location":"full_api/#MetopDatasets.LazyByteField","page":"Full API","title":"MetopDatasets.LazyByteField","text":"LazyByteField <: AbstractVector{Vector{UInt8}}\n\nType to read fields from records as a byte vector Note that LazyByteField does not work with conversion to netCDF.\n\n\n\n\n\n","category":"type"},{"location":"full_api/#MetopDatasets.RecordHeader","page":"Full API","title":"MetopDatasets.RecordHeader","text":"RecordHeader\n\nAlso known as GRH.\n\n\n\n\n\n","category":"type"},{"location":"#MetopDatasets.jl","page":"Introduction","title":"MetopDatasets.jl","text":"MetopDatasets.jl is a package for reading products from the METOP satellites using the native binary format specified for each product. The METOP satellites are part of the EUMETSAT-POLAR-SYSTEM (EPS) and have produced near real-time, global weather and climate observation since 2007. Learn more and access the products on EUMETSATs user-portal.\n\nMetopDatasets.jl exports the MetopDataset API which is an implementation of the CommonDataModel.jl interface and thus provides data access similar to e.g. NCDatasets.jl and GRIBDatasets.jl.\n\nOnly a subset of the METOP native formats are supported currently, but we are continuously adding formats. The goal is to support all publicly available native METOP products. See Supported formats for more information.\n\nIt is also possible to use MetopDatasets.jl from Python. See Use with Python for more information.","category":"section"},{"location":"#Quick-start","page":"Introduction","title":"Quick start","text":"This section gives a very short overview of the core functionalities. The MetopDataset page is recommend for more information and more specific examples are given in the Example section e.g. ASCAT. The NCDatasets documentation is also a great resource for information on how to use the datasets. ","category":"section"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"MetopDatasets.jl can be installed via Pkg.\n\nimport Pkg\nPkg.add(\"MetopDatasets\")","category":"section"},{"location":"#Read-data-from-a-Metop-Native-binary-file","page":"Introduction","title":"Read data from a Metop Native binary file","text":"Read a Metop Native binary file and display meta data:\n\nusing MetopDatasets\nds = MetopDataset(\"ASCA_SZO_1B_M03_20230329063300Z_20230329063556Z_N_C_20230329081417Z\")\n\nREPL output:\n\nDataset: \nGroup: /\n\nDimensions\n   num_band = 3\n   xtrack = 42\n   atrack = 48\n\nVariables\n  record_start_time   (48)\n    Datatype:    Dates.DateTime (Float64)\n    Dimensions:  atrack\n    Attributes:\n     description          = Record header start time\n     units                = seconds since 2000-1-1 0:0:0\n\n  record_stop_time   (48)\n    Datatype:    Dates.DateTime (Float64)\n    Dimensions:  atrack\n    Attributes:\n     description          = Record header stop time\n     units                = seconds since 2000-1-1 0:0:0\n\n  degraded_inst_mdr   (48)\n    Datatype:    Union{Missing, UInt8} (UInt8)\n    Dimensions:  atrack\n    Attributes:\n     description          = Quality of MDR has been degraded from nominal due to an instrument degradation.\n     missing_value        = UInt8[0xff]\n\n  degraded_proc_mdr   (48)\n    Datatype:    Union{Missing, UInt8} (UInt8)\n    Dimensions:  atrack\n    Attributes:\n     description          = Quality of MDR has been degraded from nominal due to a processing degradation. \n     missing_value        = UInt8[0xff]\n\n  utc_line_nodes   (48)\n    Datatype:    Dates.DateTime (Float64)\n    Dimensions:  atrack\n    Attributes:\n     description          = UTC time of line of nodes\n     units                = seconds since 2000-1-1 0:0:0\n\n  abs_line_number   (48)\n    Datatype:    Union{Missing, Int32} (Int32)\n    Dimensions:  atrack\n    Attributes:\n     description          = Absolute (unique) counter for the line of nodes (from format version 12.0 onwards only)\n     missing_value        = Int32[-2147483648]\n\n  sat_track_azi   (48)\n    Datatype:    Union{Missing, Float64} (UInt16)\n    Dimensions:  atrack\n    Attributes:\n     description          = Azimuth angle bearing (range: 0 to 360) of nadir track velocity\n     missing_value        = UInt16[0xffff]\n     scale_factor         = 0.010000000000000002\n\n  as_des_pass   (48)\n    Datatype:    Union{Missing, UInt8} (UInt8)\n    Dimensions:  atrack\n    Attributes:\n     description          = Ascending/descending pass indicator (0=DESC, 1=ASC)\n     missing_value        = UInt8[0xff]\n\n  swath_indicator   (42 × 48)\n    Datatype:    Union{Missing, UInt8} (UInt8)\n    Dimensions:  xtrack × atrack\n    Attributes:\n     description          = Swath (0=LEFT, 1=RIGHT)\n     missing_value        = UInt8[0xff]\n\n  latitude   (42 × 48)\n    Datatype:    Union{Missing, Float64} (Int32)\n    Dimensions:  xtrack × atrack\n    Attributes:\n     description          = Latitude (-90 to 90 deg)\n     missing_value        = Int32[-2147483648]\n     scale_factor         = 1.0e-6\n\n  longitude   (42 × 48)\n    Datatype:    Union{Missing, Float64} (Int32)\n    Dimensions:  xtrack × atrack\n    Attributes:\n     description          = Longitude (0 to 360 deg)\n     missing_value        = Int32[-2147483648]\n     scale_factor         = 1.0e-6\n\n  sigma0_trip   (3 × 42 × 48)\n    Datatype:    Union{Missing, Float64} (Int32)\n    Dimensions:  num_band × xtrack × atrack\n    Attributes:\n     description          = Sigma0 triplet, re-sampled to swath grid, for 3 beams (fore, mid, aft) \n     missing_value        = Int32[-2147483648]\n     scale_factor         = 1.0e-6\n\n  kp   (3 × 42 × 48)\n    Datatype:    Union{Missing, Float64} (UInt16)\n    Dimensions:  num_band × xtrack × atrack\n    Attributes:\n     description          = Kp for re-sampled sigma0 triplet. Values between 0 and 1\n     missing_value        = UInt16[0xffff]\n     scale_factor         = 0.0001\n\n  inc_angle_trip   (3 × 42 × 48)\n    Datatype:    Union{Missing, Float64} (UInt16)\n    Dimensions:  num_band × xtrack × atrack\n    Attributes:\n     description          = Incidence angle for re-sampled sigma0 triplet.\n     missing_value        = UInt16[0xffff]\n     scale_factor         = 0.010000000000000002\n\n  azi_angle_trip   (3 × 42 × 48)\n    Datatype:    Union{Missing, Float64} (Int16)\n    Dimensions:  num_band × xtrack × atrack\n    Attributes:\n     description          = Azimuth angle of the up-wind direction for a given measurement triplet (range: -180 to +180, where minus is west and plus is east with respect to North)\n     missing_value        = Int16[-32768]\n     scale_factor         = 0.010000000000000002\n\n  num_val_trip   (3 × 42 × 48)\n    Datatype:    Union{Missing, UInt32} (UInt32)\n    Dimensions:  num_band × xtrack × atrack\n    Attributes:\n     description          = Number of full resolution sigma0 values contributing to the re-sampled sigma0 triplet.\n     missing_value        = UInt32[0xffffffff]\n\n  f_kp   (3 × 42 × 48)\n    Datatype:    Union{Missing, UInt8} (UInt8)\n    Dimensions:  num_band × xtrack × atrack\n    Attributes:\n     description          = Flag related to the quality of the Kp estimate (0=NOMINAL, 1=NON-NOMINAL)\n     missing_value        = UInt8[0xff]\n\n  f_usable   (3 × 42 × 48)\n    Datatype:    Union{Missing, UInt8} (UInt8)\n    Dimensions:  num_band × xtrack × atrack\n    Attributes:\n     description          = Flag related to the usability of the sigma0 triplet (0=GOOD, 1=USABLE, 2=NOT USABLE)        \n     missing_value        = UInt8[0xff]\n\n  f_land   (3 × 42 × 48)\n    Datatype:    Union{Missing, Float64} (UInt16)\n    Dimensions:  num_band × xtrack × atrack\n    Attributes:\n     description          = Flag related to presence of land in the re-sampled sigma0 triplet (based on land mask; value between 0 and 1 shows the fraction of original samples affected)\n     missing_value        = UInt16[0xffff]\n     scale_factor         = 0.001\n\n  lcr   (3 × 42 × 48)\n    Datatype:    Union{Missing, Float64} (UInt16)\n    Dimensions:  num_band × xtrack × atrack\n    Attributes:\n     description          = Land Contamination Ratio estimate (based on SRF)\n     missing_value        = UInt16[0xffff]\n     scale_factor         = 0.0001\n\n  flagfield   (3 × 42 × 48)\n    Datatype:    Union{Missing, UInt32} (UInt32)\n    Dimensions:  num_band × xtrack × atrack\n    Attributes:\n     description          = Flag field containing quality information\n     missing_value        = UInt32[0xffffffff]\n\nGlobal attributes\n  product_name         = ASCA_SZO_1B_M03_20230329063300Z_20230329063556Z_N_C_20230329081417Z\n  parent_product_name_1 = ASCA_xxx_1A_M03_20230329063300Z_20230329063559Z_N_C_20230329081221Z\n  parent_product_name_2 = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n  parent_product_name_3 = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n  parent_product_name_4 = xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n  instrument_id        = ASCA\n  instrument_model     = 1\n  product_type         = SZO\n  processing_level     = 1B\n  spacecraft_id        = M03\n  sensing_start        = 2023-03-29T06:33:00\n  sensing_end          = 2023-03-29T06:35:56\n  sensing_start_theoretical = 2023-03-29T06:06:00\n  sensing_end_theoretical = 2023-03-29T07:48:00\n  processing_centre    = CGS2\n  processor_major_version = 11\n  processor_minor_version = 3\n  format_major_version = 13\n  format_minor_version = 1\n  processing_time_start = 2023-03-29T08:14:17\n  processing_time_end  = 2023-03-29T08:14:25\n  processing_mode      = N\n  disposition_mode     = C\n  receiving_ground_station = SVL\n  receive_time_start   = 2023-03-29T07:41:22\n  receive_time_end     = 2023-03-29T07:42:22\n  orbit_start          = 22777\n  orbit_end            = 22778\n  actual_product_size  = 171868\n  state_vector_time    = 2023-03-29T05:33:10.999\n  semi_major_axis      = 7204607302\n  eccentricity         = 1053\n  inclination          = 98685\n  perigee_argument     = 57931\n  right_ascension      = 149006\n  mean_anomaly         = 302003\n  x_position           = -3668934509\n  y_position           = -6195727325\n  z_position           = -20970818\n  x_velocity           = -1426267\n  y_velocity           = 827418\n  z_velocity           = 7356929\n  earth_sun_distance_ratio = 998227\n  location_tolerance_radial = 0\n  location_tolerance_crosstrack = 0\n  location_tolerance_alongtrack = 0\n  yaw_error            = 0\n  roll_error           = 0\n  pitch_error          = 0\n  subsat_latitude_start = -32200\n  subsat_longitude_start = 38892\n  subsat_latitude_end  = -42446\n  subsat_longitude_end = 35658\n  leap_second          = 0\n  leap_second_utc      =\n  total_records        = 67\n  total_mphr           = 1\n  total_sphr           = 1\n  total_ipr            = 9\n  total_geadr          = 1\n  total_giadr          = 0\n  total_veadr          = 5\n  total_viadr          = 2\n  total_mdr            = 48\n  count_degraded_inst_mdr = 0\n  count_degraded_proc_mdr = 0\n  count_degraded_inst_mdr_blocks = 0\n  count_degraded_proc_mdr_blocks = 0\n  duration_of_product  = 176250\n  milliseconds_of_data_present = 176250\n  milliseconds_of_data_missing = 0\n  subsetted_product    = F\n\nThe variables can be loaded from MetopDataset by indexing the dataset. The variable then works as a lazy array loading the data on indexing:\n\nds[\"latitude\"][2,4]\n\nREPL output:\n\n-34.351729\n\nIt is also possible to load the complete array\n\nds[\"latitude\"][:,:]\n\nREPL output:\n\n42×48 Matrix{Union{Missing, Float64}}:\n -33.7308  -33.949   …  -43.7545  -43.9721\n -33.6969  -33.9152     -43.7252  -43.9429\n -33.6624  -33.8808     -43.695   -43.9127\n -33.6274  -33.8458     -43.6639  -43.8818\n   ⋮                 ⋱                    \n -30.1606  -30.3748     -39.9343  -40.1446\n -30.0909  -30.3049  …  -39.8538  -40.0638\n -30.0206  -30.2344     -39.7726  -39.9823\n\nData from the main product header is accessed as attributes.\n\nds.attrib[\"instrument_id\"]\n\nREPL output:\n\n\"ASCA\"","category":"section"},{"location":"#Convert-a-Metop-Native-binary-file-to-netCDF","page":"Introduction","title":"Convert a Metop Native binary file to netCDF","text":"A Metop Native binary file can be converted to netCDF using the NCDatasets.jl package. This  is possible because both MetopDatasets.jl and NCDatasets.jl implement the CommonDataModel.jl interface.\n\nusing MetopDatasets\nusing NCDatasets\n\ninput_file = \"ASCA_SZR_1B_M01_20190109125700Z_20190109143858Z_N_O_20190109134816Z.nat\"\noutput_file = \"ASCA_SZR_1B_M01_20190109125700Z_20190109143858Z_N_O_20190109134816Z.nc\"\n\nds_native = MetopDataset(input_file)\nds_nc = NCDataset(output_file, \"c\") \nNCDatasets.write(ds_nc, ds_native)\n\nclose(ds_native)\nclose(ds_nc)\n\nIt is also possible to use the safe do syntax that ensures the files are closed correctly even in the case of exceptions.\n\nusing MetopDatasets\nusing NCDatasets\n\ninput_file = \"ASCA_SZR_1B_M01_20190109125700Z_20190109143858Z_N_O_20190109134816Z.nat\"\noutput_file = \"ASCA_SZR_1B_M01_20190109125700Z_20190109143858Z_N_O_20190109134816Z.nc\"\n\nMetopDataset(input_file) do ds_native\n  NCDataset(output_file, \"c\") do ds_nc\n    NCDatasets.write(ds_nc, ds_native)\n  end\nend","category":"section"},{"location":"#Supported-formats","page":"Introduction","title":"Supported formats","text":"AMSU-A Level 1B\nASCAT Level 1B\nASCAT Level 2 Soil Moisture\nHIRS Level 1B\nIASI Level 1C\nIASI Level 2 Combined Sounding\nMHS Level 1B ","category":"section"},{"location":"#Formats-not-yet-supported","page":"Introduction","title":"Formats not yet supported","text":"AVHRR Level 1B\nGOME-2 Level 1B\nIASI Level 1C Principal Component Scores","category":"section"},{"location":"#Reference-documents","page":"Introduction","title":"Reference documents","text":"EPS Generic Product Format Specification\nAMSU-A Level 1 Product Format Specification\nASCAT Level 1: Product Format Specification\nASCAT Level 2 Soil Moisture: Product Format Specification\nHIRS Level 1 Product Format Specification\nIASI Level 1 Product Format Specification\nIASI Level 2: Product Format Specification\nMHS Level 1 Product Format Specification","category":"section"},{"location":"#Development-status-and-versioning","page":"Introduction","title":"Development status and versioning","text":"The package was previously named MetopNative.jl and was hosted on the EUMETSAT GitLab.\n\nThe aim is to follow the semantic versioning system. Note that the package is still 0.x.y to signal that breaking changes are to be expected. This is done to allow for more rapid development and because major dependencies like the CommonDataModel.jl are not at the version 1.0 milestone yet. It is therefore recommended to use Pkg environments for projects with MetopDatasets.jl to handle comparability and ensure reproducibility. Please note that many of the \"breaking changes\" will be small and only affect specific use cases. This could for example be the correction of a single variable name. All breaking changes are marked in the changelog.","category":"section"}]
}
